<!DOCTYPE html>
<html lang='en'>
<head>
	<title>SpringRoll Container v0.4.0 API Documentation : src/container/Container.js</title>
	<meta charset='utf-8'>
	<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
	<link rel='shortcut icon' type='image/png' href='../assets/images/favicon.ico?v=0.4.0'>
	<link href='//fonts.googleapis.com/css?family=Titillium+Web:300,200,600' rel='stylesheet' type='text/css'>
	<link rel='stylesheet' type='text/css' href='../assets/css/libraries.css?v=0.4.0'>
	<link rel='stylesheet' type='text/css' href='../assets/css/main.css?v=0.4.0'>
</head>
<body>
<header>
	<nav class="navbar navbar-inverse navbar-fixed-top">
		<div class='container'>
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#docs-navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href='https://github.com/SpringRoll/SpringRollContainer'>
						<img src='../assets/images/logo.png?v=0.4.0' class="logo">
					<span class='project-name'>SpringRoll Container</span>
					<span class="sr-only">API Documentation for:</span>
					<span class='version hidden-xs'>v0.4.0</span>
				</a>
			</div>
			<div class="collapse navbar-collapse" id="docs-navbar">
	      <ul class="scope-toggles text-center nav navbar-nav navbar-right">
					<li><input class='scope-toggle' 
						id='toggle-inherited' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Inherited' 
						data-off='Inherited' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-protected' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Protected' 
						data-off='Protected' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-private' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Private' 
						data-off='Private' 
						data-size='mini'
						data-width='80'>
					</li>
					<li><input class='scope-toggle' 
						id='toggle-deprecated' 
						type='checkbox' 
						data-toggle='toggle' 
						data-on='Deprecated' 
						data-off='Deprecated' 
						data-size='mini'
						data-width='80'>
					</li>
				</ul>
			</div>
		</div>
	</nav>
</header>
<div class='container'>
<div class='row'>
<nav id='sidebar' class='col-sm-4 col-md-3'>
<h2>APIs</h2>
<div class='input-group'>
  <div class='input-group-addon'>
    <span class='glyphicon glyphicon-search'></span>
  </div>
  <input type='search' class='form-control' id='api-filter' placeholder='Type to filter APIs'>
  <span class='collapsed btn-close glyphicon glyphicon-remove-sign hidden'></span>
</div>
<nav class='navbar navbar-default'>
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="btn-group" role="group" aria-label="...">
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-classes' data-target='#classes-collapse'>
      Classes
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-modules' data-target='#modules-collapse'>
      Modules
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='classes-collapse'>
    <ul class='nav navbar-nav'>
        <li class='public'>
          <a href='../classes/springroll.Container.html'>springroll.Container</a>
        </li>
        <li class='public'>
          <a href='../classes/springroll.Features.html'>springroll.Features</a>
        </li>
        <li class='public'>
          <a href='../classes/springroll.SavedDataHandler.html'>springroll.SavedDataHandler</a>
        </li>
    </ul>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='modules-collapse'>
    <ul class='nav navbar-nav'>
        <li class=''>
          <a href='../modules/Container.html'>Container</a>
        </li>
    </ul>
  </div>
  <!-- /.container-fluid -->
</nav></nav>
<div class='col-sm-8 col-md-9'>
<div id='docs-main' class='apidocs'>
<h1 class="file-heading">File:Container.js</h1>

<div class="file">
<pre class="code prettyprint linenums">/**
 * @module Container
 * @namespace springroll
 */
(function(document, undefined)
{
	//Import classes
	var SavedData = include(&#x27;springroll.SavedData&#x27;),
		EventDispatcher = include(&#x27;springroll.EventDispatcher&#x27;),
		PageVisibility = include(&#x27;springroll.PageVisibility&#x27;),
		SavedDataHandler = include(&#x27;springroll.SavedDataHandler&#x27;),
		Features = include(&#x27;springroll.Features&#x27;),
		Bellhop = include(&#x27;Bellhop&#x27;),
		$ = include(&#x27;jQuery&#x27;);

	/**
	 * The application container
	 * @class Container
	 * @extends springroll.EventDispatcher
	 * @constructor
	 * @param {string} iframeSelector jQuery selector for application iframe container
	 * @param {object} [options] Optional parameteres
	 * @param {string} [options.helpButton] jQuery selector for help button
	 * @param {string} [options.captionsButton] jQuery selector for captions button
	 * @param {string} [options.soundButton] jQuery selector for captions button
	 * @param {string} [options.voButton] jQuery selector for vo button
	 * @param {string} [options.sfxButton] jQuery selector for sounf effects button
	 * @param {string} [options.musicButton] jQuery selector for music button
	 * @param {string} [options.pauseButton] jQuery selector for pause button
	 * @param {string} [options.pauseFocusSelector=&#x27;.pause-on-focus&#x27;] The class to pause
	 *        the application when focused on. This is useful for form elements which
	 *        require focus and play better with Application&#x27;s keepFocus option.
	 */
	var Container = function(iframeSelector, options)
	{
		EventDispatcher.call(this);

		/**
		 * The options
		 * @property {Object} options
		 * @readOnly
		 */
		this.options = options = $.extend(
		{
			pauseFocusSelector: &#x27;.pause-on-focus&#x27;
		}, options ||
		{});

		/**
		 * The name of this class
		 * @property {string} name
		 */
		this.name = &#x27;springroll.Container&#x27;;

		/**
		 * The current iframe jquery object
		 * @property {jquery} iframe
		 */
		this.main = $(iframeSelector);

		/**
		 * The DOM object for the iframe
		 * @property {Element} dom
		 */
		this.dom = this.main[0];

		/**
		 * Reference to the help button
		 * @property {jquery} helpButton
		 */
		this.helpButton = $(options.helpButton)
			.click(onPlayHelp.bind(this));

		/**
		 * Reference to the captions button
		 * @property {jquery} captionsButton
		 */
		this.captionsButton = $(options.captionsButton)
			.click(onCaptionsToggle.bind(this));

		/**
		 * Reference to the all sound mute button
		 * @property {jquery} soundButton
		 */
		this.soundButton = $(options.soundButton)
			.click(onSoundToggle.bind(this));

		/**
		 * Reference to the music mute button
		 * @property {jquery} musicButton
		 */
		this.musicButton = $(options.musicButton)
			.click(onMusicToggle.bind(this));

		/**
		 * Reference to the sound effects mute button
		 * @property {jquery} sfxButton
		 */
		this.sfxButton = $(options.sfxButton)
			.click(onSFXToggle.bind(this));

		/**
		 * Reference to the voice-over mute button
		 * @property {jquery} voButton
		 */
		this.voButton = $(options.voButton)
			.click(onVOToggle.bind(this));

		/**
		 * Reference to the pause application button
		 * @property {jquery} pauseButton
		 */
		this.pauseButton = $(options.pauseButton)
			.click(onPauseToggle.bind(this));

		/**
		 * Communication layer between the container and application
		 * @property {Bellhop} client
		 */
		this.client = null;

		/**
		 * The current release data
		 * @property {Object} release
		 */
		this.release = null;

		/**
		 * Check to see if a application is loaded
		 * @property {Boolean} loaded
		 * @readOnly
		 */
		this.loaded = false;

		/**
		 * Check to see if a application is loading
		 * @property {Boolean} loading
		 * @readOnly
		 */
		this.loading = false;

		/**
		 * The collection of captions styles
		 * @property {string} _captionsStyles
		 * @private
		 */
		this._captionsStyles = Object.merge(
			{},
			DEFAULT_CAPTIONS_STYLES,
			SavedData.read(CAPTIONS_STYLES) ||
			{}
		);

		/**
		 * Whether the Game is currently &quot;blurred&quot; (not focused) - for pausing/unpausing
		 * @property {Boolean} _appBlurred
		 * @private
		 * @default  false
		 */
		this._appBlurred = false;

		/**
		 * Always keep the focus on the application iframe
		 * @property {Boolean} _keepFocus
		 * @private
		 * @default  false
		 */
		this._keepFocus = false;

		/**
		 * Whether the Container is currently &quot;blurred&quot; (not focused) - for pausing/unpausing
		 * @property {Boolean} _containerBlurred
		 * @private
		 * @default  false
		 */
		this._containerBlurred = false;

		/**
		 * Delays pausing of application to mitigate issues with asynchronous communication
		 * between Game and Container
		 * @property {int} _focusTimer
		 */
		this._focusTimer = null;

		/**
		 * If the application is currently paused manually
		 * @property {boolean} _isManualPause
		 * @private
		 * @default false
		 */
		this._isManualPause = false;

		/**
		 * If the current application is paused
		 * @property {Boolean} _paused
		 * @private
		 * @default false
		 */
		this._paused = false;

		/**
		 * Should we send bellhop messages for the mute (etc) buttons?
		 * @property {Boolean} sendMutes
		 * @default true
		 */
		this.sendMutes = true;

		/**
		 * The external handler class, must include &#x60;remove&#x60;, &#x60;write&#x60;, &#x60;read&#x60; methods
		 * make it possible to use something else to handle the external, default
		 * is to use cookies/localStorage. See {{#crossLink &quot;springroll.SavedDataHandler&quot;}}{{/crossLink}}
		 * as an example.
		 * @property {Object} userDataHandler
		 * @default springroll.SavedDataHandler
		 */
		this.userDataHandler = new SavedDataHandler();

		//Set the defaults if we have none for the controls
		if (SavedData.read(CAPTIONS_MUTED) === null)
		{
			this.captionsMuted = true;
		}
		if (SavedData.read(SOUND_MUTED) === null)
		{
			this.soundMuted = false;
		}

		this._pageVisibility = new PageVisibility(
			onContainerFocus.bind(this),
			onContainerBlur.bind(this)
		);

		// Focus on the window on focusing on anything else
		// without the .pause-on-focus class
		this._onDocClick = _onDocClick.bind(this);
		$(document).on(&#x27;focus click&#x27;, this._onDocClick);

		// Bind close failed handler
		this._onCloseFailed = this._onCloseFailed.bind(this);

		// On elements with the class name pause-on-focus
		// we will pause the game until a blur event to that item
		// has been sent
		var self = this;
		$(options.pauseFocusSelector).on(&#x27;focus&#x27;, function()
		{
			self._isManualPause = self.paused = true;
			$(this).one(&#x27;blur&#x27;, function()
			{
				self._isManualPause = self.paused = false;
				self.focus();
			});
		});
	};

	//Reference to the prototype
	var s = EventDispatcher.prototype;
	var p = EventDispatcher.extend(Container);

	/**
	 * Fired when the pause state is toggled
	 * @event pause
	 * @param {boolean} paused If the application is now paused
	 */

	/**
	 * Fired when the application resumes from a paused state
	 * @event resumed
	 */

	/**
	 * Fired when the application becomes paused
	 * @event paused
	 */

	/**
	 * Fired when the application is unsupported
	 * @event unsupported
	 * @param {String} err The error message
	 */

	/**
	 * Fired when the API cannot be called
	 * @event remoteFailed
	 */

	/**
	 * There was a problem with the API call
	 * @event remoteError
	 */

	/**
	 * There was an uncaught iframe error destroying the game on closing
	 * @event localError
	 * @param {Error} error The error triggered
	 */

	/**
	 * Event when the application gives the load done signal
	 * @event opened
	 */

	/**
	 * Event when a application starts closing
	 * @event close
	 */

	/**
	 * Event when a application closes
	 * @event closed
	 */

	/**
	 * Event when request to open an application has begin either by
	 * calling &#x60;openPath&#x60; or &#x60;openRemote&#x60;
	 * @event open
	 */

	/**
	 * Event when a application start loading, first even received
	 * from the Application.
	 * @event opening
	 */

	/**
	 * Fired when the enabled status of the help button changes
	 * @event helpEnabled
	 * @param {boolean} enabled If the help button is enabled
	 */

	/**
	 * The features supported by the application
	 * @event features
	 * @param {Boolean} data.vo If VO vo context is supported
	 * @param {Boolean} data.music If music context is supported
	 * @param {Boolean} data.sound If Sound is supported
	 * @param {Boolean} data.sfx If SFX context is supported
	 * @param {Boolean} data.captions If captions is supported
	 * @param {Boolean} data.hints If hinting is supported
	 */

	/**
	 * When the document is clicked
	 * @method _onDocClicked
	 * @private
	 * @param  {Event} e Click or focus event
	 */
	var _onDocClick = function(e)
	{
		if (!this.loaded) return;

		if (!$(e.target).filter(this.options.pauseFocusSelector).length)
		{
			this.focus();
		}
	};

	/**
	 * Open a application or path
	 * @method _internalOpen
	 * @private
	 * @param {string} path The full path to the application to load
	 * @param {Object} [options] The open options
	 * @param {Boolean} [options.singlePlay=false] If we should play in single play mode
	 * @param {Object} [options.playOptions=null] The optional play options
	 */
	p._internalOpen = function(path, options)
	{
		options = $.extend(
		{
			singlePlay: false,
			playOptions: null
		}, options);

		this.reset();

		// Dispatch event for unsupported browsers
		// and then bail, don&#x27;t continue with loading the application
		var err = Features.basic();
		if (err)
		{
			return this.trigger(&#x27;unsupported&#x27;, err);
		}

		this.loading = true;

		this.initClient();

		//Open the application in the iframe
		this.main
			.addClass(&#x27;loading&#x27;)
			.prop(&#x27;src&#x27;, path);

		// Respond with data when we&#x27;re ready
		this.client.respond(&#x27;singlePlay&#x27;, options.singlePlay);
		this.client.respond(&#x27;playOptions&#x27;, options.playOptions);

		this.trigger(&#x27;open&#x27;);
	};

	/**
	 * Open a application or path
	 * @method openPath
	 * @param {string} path The full path to the application to load
	 * @param {Object} [options] The open options
	 * @param {Boolean} [options.singlePlay=false] If we should play in single play mode
	 * @param {Object} [options.playOptions=null] The optional play options
	 */
	p.openPath = function(path, options, playOptions)
	{
		options = options ||
		{};

		// This should be deprecated, support for old function signature
		if (typeof options === &quot;boolean&quot;)
		{
			options = {
				singlePlay: singlePlay,
				playOptions: playOptions
			};
		}
		this._internalOpen(path, options);
	};

	/**
	 * Open application based on an API Call to SpringRoll Connect
	 * @method openRemote
	 * @param {string} api The path to API call, this can be a full URL
	 * @param {Object} [options] The open options
	 * @param {Boolean} [options.singlePlay=false] If we should play in single play mode
	 * @param {Object} [options.playOptions=null] The optional play options
	 * @param {String} [options.query=&#x27;&#x27;] The application query string options (e.g., &quot;?level=1&quot;)
	 */
	p.openRemote = function(api, options, playOptions)
	{
		// This should be deprecated, support for old function signature
		if (typeof options === &quot;boolean&quot;)
		{
			options = {
				singlePlay: singlePlay,
				playOptions: playOptions
			};
		}
		options = $.extend(
		{
			query: &#x27;&#x27;,
			playOptions: null,
			singlePlay: false
		}, options);

		this.release = null;

		$.getJSON(api, function(result)
				{
					if (this._destroyed) return;

					if (!result.success)
					{
						return this.trigger(&#x27;remoteError&#x27;, result.error);
					}
					var release = result.data;

					var err = Features.test(release.capabilities);

					if (err)
					{
						return this.trigger(&#x27;unsupported&#x27;, err);
					}

					this.release = release;

					// Open the application
					this._internalOpen(release.url + options.query, options);
				}
				.bind(this))
			.fail(function()
				{
					if (this._destroyed) return;
					return this.trigger(&#x27;remoteFailed&#x27;);
				}
				.bind(this));
	};

	/**
	 * Set up communication layer between site and application.
	 * May be called from subclasses if they create/destroy Bellhop instances.
	 * @protected
	 * @method initClient
	 */
	p.initClient = function()
	{
		//Setup communication layer between site and application
		this.client = new Bellhop();
		this.client.connect(this.dom);

		//Handle bellhop events coming from the application
		this.client.on(
		{
			loading: onLoading.bind(this),
			loadDone: onLoadDone.bind(this), // @deprecated use &#x27;loaded&#x27; instead
			loaded: onLoadDone.bind(this),
			endGame: onEndGame.bind(this),
			focus: onFocus.bind(this),
			helpEnabled: onHelpEnabled.bind(this),
			features: onFeatures.bind(this),
			keepFocus: onKeepFocus.bind(this),
			userDataRemove: onUserDataRemove.bind(this),
			userDataRead: onUserDataRead.bind(this),
			userDataWrite: onUserDataWrite.bind(this),
			localError: onLocalError.bind(this)
		});
	};

	/**
	 * Removes the Bellhop communication layer altogether.
	 * @protected
	 * @method destroyClient
	 */
	p.destroyClient = function()
	{
		if (this.client)
		{
			this.client.destroy();
			this.client = null;
		}
	};

	/**
	 * Handler for the userDataRemove event
	 * @method onUserDataRemove
	 * @private
	 */
	var onUserDataRemove = function(event)
	{
		var client = this.client;
		this.userDataHandler.remove(event.data, function()
		{
			client.send(event.type);
		});
	};

	/**
	 * Handler for the userDataRead event
	 * @method onUserDataRead
	 * @private
	 */
	var onUserDataRead = function(event)
	{
		var client = this.client;
		this.userDataHandler.read(event.data, function(value)
		{
			client.send(event.type, value);
		});
	};

	/**
	 * Handler for the userDataWrite event
	 * @method onUserDataWrite
	 * @private
	 */
	var onUserDataWrite = function(event)
	{
		var data = event.data;
		var client = this.client;
		this.userDataHandler.write(data.name, data.value, function()
		{
			client.send(event.type);
		});
	};

	/**
	 * Handle the local errors
	 * @method onLocalError
	 * @private
	 * @param  {Event} event Bellhop event
	 */
	var onLocalError = function(event)
	{
		this.trigger(event.type, event.data);
	};

	/**
	 * The game is starting to load
	 * @method onLoading
	 * @private
	 */
	var onLoading = function()
	{
		this.trigger(&#x27;opening&#x27;);
	};

	/**
	 * Reset the mutes for audio and captions
	 * @method onLoadDone
	 * @private
	 */
	var onLoadDone = function()
	{
		this.loading = false;
		this.loaded = true;
		this.main.removeClass(&#x27;loading&#x27;);

		this.captionsButton.removeClass(&#x27;disabled&#x27;);
		this.soundButton.removeClass(&#x27;disabled&#x27;);
		this.sfxButton.removeClass(&#x27;disabled&#x27;);
		this.voButton.removeClass(&#x27;disabled&#x27;);
		this.musicButton.removeClass(&#x27;disabled&#x27;);
		this.pauseButton.removeClass(&#x27;disabled&#x27;);

		this.captionsMuted = !!SavedData.read(CAPTIONS_MUTED);
		this.soundMuted = !!SavedData.read(SOUND_MUTED);
		this.musicMuted = !!SavedData.read(MUSIC_MUTED);
		this.sfxMuted = !!SavedData.read(SFX_MUTED);
		this.voMuted = !!SavedData.read(VO_MUTED);

		this.setCaptionsStyles(SavedData.read(CAPTIONS_STYLES));

		// Loading is done
		this.trigger(&#x27;opened&#x27;);

		// Focus on the content
		this.focus();

		// Reset the paused state
		this.paused = this._paused;
	};

	/**
	 * Handle focus events sent from iFrame children
	 * @method onFocus
	 * @private
	 */
	var onFocus = function(e)
	{
		this._appBlurred = !e.data;
		this.manageFocus();
	};

	/**
	 * Handle focus events sent from container&#x27;s window
	 * @method onContainerFocus
	 * @private
	 */
	var onContainerFocus = function(e)
	{
		this._containerBlurred = false;
		this.manageFocus();
	};

	/**
	 * Handle blur events sent from container&#x27;s window
	 * @method onContainerBlur
	 * @private
	 */
	var onContainerBlur = function(e)
	{
		//Set both container and application to blurred,
		//because some blur events are only happening on the container.
		//If container is blurred because application area was just focused,
		//the application&#x27;s focus event will override the blur imminently.
		this._containerBlurred = this._appBlurred = true;
		this.manageFocus();
	};

	/**
	 * Focus on the iframe&#x27;s contentWindow
	 * @method focus
	 */
	p.focus = function()
	{
		this.dom.contentWindow.focus();
	};

	/**
	 * Unfocus on the iframe&#x27;s contentWindow
	 * @method blur
	 */
	p.blur = function()
	{
		this.dom.contentWindow.blur();
	};

	/**
	 * Manage the focus change events sent from window and iFrame
	 * @method manageFocus
	 * @protected
	 */
	p.manageFocus = function()
	{
		// Unfocus on the iframe
		if (this._keepFocus)
		{
			this.blur();
		}

		// we only need one delayed call, at the end of any
		// sequence of rapidly-fired blur/focus events
		if (this._focusTimer)
		{
			clearTimeout(this._focusTimer);
		}

		// Delay setting of &#x27;paused&#x27; in case we get another focus event soon.
		// Focus events are sent to the container asynchronously, and this was
		// causing rapid toggling of the pause state and related issues,
		// especially in Internet Explorer
		this._focusTimer = setTimeout(
			function()
			{
				this._focusTimer = null;
				// A manual pause cannot be overriden by focus events.
				// User must click the resume button.
				if (this._isManualPause) return;

				this.paused = this._containerBlurred &amp;&amp; this._appBlurred;

				// Focus on the content window when blurring the app
				// but selecting the container
				if (this._keepFocus &amp;&amp; !this._containerBlurred &amp;&amp; this._appBlurred)
				{
					this.focus();
				}

			}.bind(this),
			100
		);
	};

	/**
	 * Handle the application features
	 * @method onFeatures
	 * @param {event} event The bellhop features
	 * @private
	 */
	var onFeatures = function(event)
	{
		var features = event.data;

		this.voButton.hide();
		this.musicButton.hide();
		this.soundButton.hide();
		this.captionsButton.hide();
		this.helpButton.hide();

		if (features.vo) this.voButton.show();
		if (features.music) this.musicButton.show();
		if (features.sound) this.soundButton.show();
		if (features.captions) this.captionsButton.show();
		if (features.hints) this.helpButton.show();

		this.trigger(&#x27;features&#x27;, features);
	};

	/**
	 * Handle the keep focus event for the window
	 * @method onKeepFocus
	 * @private
	 */
	var onKeepFocus = function(event)
	{
		this._keepFocus = !!event.data;
		this.manageFocus();
	};

	/**
	 * Reset the mutes for audio and captions
	 * @method onHelpEnabled
	 * @private
	 */
	var onHelpEnabled = function(event)
	{
		this.helpEnabled = !!event.data;
	};

	/**
	 * Handler when the play hint button is clicked
	 * @method onPlayHelp
	 * @private
	 */
	var onPlayHelp = function()
	{
		if (!this.paused &amp;&amp; !this.helpButton.hasClass(&#x27;disabled&#x27;))
		{
			this.client.send(&#x27;playHelp&#x27;);
		}
	};

	/**
	 * The application ended and destroyed itself
	 * @method onEndGame
	 * @private
	 */
	var onEndGame = function()
	{
		this.reset();
	};

	/**
	 * Handler when the captions mute button is clicked
	 * @method onCaptionsToggle
	 * @private
	 */
	var onCaptionsToggle = function()
	{
		this.captionsMuted = !this.captionsMuted;
	};

	/**
	 * If the current application is paused
	 * @property {Boolean} paused
	 * @default false
	 */
	Object.defineProperty(p, &#x27;paused&#x27;,
	{
		set: function(paused)
		{
			this._paused = paused;

			if (this.client)
			{
				this.client.send(&#x27;pause&#x27;, paused);
			}
			this.trigger(paused ? &#x27;paused&#x27; : &#x27;resumed&#x27;);
			this.trigger(&#x27;pause&#x27;, paused);

			// Set the pause button state
			this.pauseButton.removeClass(&#x27;unpaused paused&#x27;)
				.addClass(paused ? &#x27;paused&#x27; : &#x27;unpaused&#x27;);

			// Disable the help button when paused if it&#x27;s active
			if (paused &amp;&amp; !this.helpButton.hasClass(&#x27;disabled&#x27;))
			{
				this.helpButton.data(&#x27;paused&#x27;, true);
				this.helpEnabled = false;
			}
			else if (this.helpButton.data(&#x27;paused&#x27;))
			{
				this.helpButton.removeData(&#x27;paused&#x27;);
				this.helpEnabled = true;
			}
		},
		get: function()
		{
			return this._paused;
		}
	});

	/**
	 * Set the captions are muted
	 * @property {Boolean} helpEnabled
	 */
	Object.defineProperty(p, &#x27;helpEnabled&#x27;,
	{
		set: function(enabled)
		{
			this._helpEnabled = enabled;
			this.helpButton.removeClass(&#x27;disabled enabled&#x27;)
				.addClass(enabled ? &#x27;enabled&#x27; : &#x27;disabled&#x27;);

			this.trigger(&#x27;helpEnabled&#x27;, enabled);
		},
		get: function()
		{
			return this._helpEnabled;
		}
	});

	/**
	 * Handler when the sound mute button is clicked
	 * @method onSoundToggle
	 * @private
	 */
	var onSoundToggle = function()
	{
		var muted = !this.soundMuted;
		this.soundMuted = muted;
		this.musicMuted = muted;
		this.voMuted = muted;
		this.sfxMuted = muted;
	};

	/**
	 * Handler when the music mute button is clicked
	 * @method onMusicToggle
	 * @private
	 */
	var onMusicToggle = function()
	{
		this.musicMuted = !this.musicMuted;
		this._checkSoundMute();
	};

	/**
	 * Handler when the voice-over mute button is clicked
	 * @method onVOToggle
	 * @private
	 */
	var onVOToggle = function()
	{
		this.voMuted = !this.voMuted;
		this._checkSoundMute();
	};

	/**
	 * Handler when the voice-over mute button is clicked
	 * @method onSFXToggle
	 * @private
	 */
	var onSFXToggle = function()
	{
		this.sfxMuted = !this.sfxMuted;
		this._checkSoundMute();
	};

	/**
	 * Check for when all mutes are muted or unmuted
	 * @method _checkSoundMute
	 * @private
	 */
	p._checkSoundMute = function()
	{
		this.soundMuted = this.sfxMuted &amp;&amp; this.voMuted &amp;&amp; this.musicMuted;
	};

	/**
	 * Toggle the current paused state of the application
	 * @method onPauseToggle
	 * @private
	 */
	var onPauseToggle = function()
	{
		this.paused = !this.paused;
		this._isManualPause = this.paused;
	};

	/**
	 * The name of the saved property if the captions are muted or not
	 * @property {string} CAPTIONS_MUTED
	 * @static
	 * @private
	 * @final
	 */
	var CAPTIONS_MUTED = &#x27;captionsMuted&#x27;;

	/**
	 * The name of the saved property if the sound is muted or not
	 * @property {string} SOUND_MUTED
	 * @static
	 * @private
	 * @final
	 */
	var SOUND_MUTED = &#x27;soundMuted&#x27;;

	/**
	 * The name of the saved property if the music is muted or not
	 * @property {string} MUSIC_MUTED
	 * @static
	 * @private
	 * @final
	 */
	var MUSIC_MUTED = &#x27;musicMuted&#x27;;

	/**
	 * The name of the saved property if the voice-over is muted or not
	 * @property {string} VO_MUTED
	 * @static
	 * @private
	 * @final
	 */
	var VO_MUTED = &#x27;voMuted&#x27;;

	/**
	 * The name of the saved property if the effects are muted or not
	 * @property {string} SFX_MUTED
	 * @static
	 * @private
	 * @final
	 */
	var SFX_MUTED = &#x27;sfxMuted&#x27;;

	/**
	 * The name of the saved property for the captions styles
	 * @property {string} CAPTIONS_STYLES
	 * @static
	 * @private
	 * @final
	 */
	var CAPTIONS_STYLES = &#x27;captionsStyles&#x27;;

	/**
	 * The map of the default caption style settings
	 * @property {object} DEFAULT_CAPTIONS_STYLES
	 * @static
	 * @private
	 * @final
	 */
	var DEFAULT_CAPTIONS_STYLES = {
		size: &quot;md&quot;,
		background: &quot;black-semi&quot;,
		color: &quot;white&quot;,
		edge: &quot;none&quot;,
		font: &quot;arial&quot;,
		align: &quot;top&quot;
	};

	/**
	 * Abstract method to handle the muting
	 * @method _setMuteProp
	 * @param {string} prop The name of the property to save
	 * @param {jquery} button Reference to the jquery button
	 * @param {boolean} muted  If the button is muted
	 */
	p._setMuteProp = function(prop, button, muted)
	{
		button.removeClass(&#x27;unmuted muted&#x27;)
			.addClass(muted ? &#x27;muted&#x27; : &#x27;unmuted&#x27;);

		SavedData.write(prop, muted);
		if (this.client &amp;&amp; this.sendMutes)
		{
			this.client.send(prop, muted);
		}
	};

	/**
	 * Set the captions styles
	 * @method setCaptionsStyles
	 * @param {object|String} [styles] The style options or the name of the
	 * property (e.g., &quot;color&quot;, &quot;edge&quot;, &quot;font&quot;, &quot;background&quot;, &quot;size&quot;)
	 * @param {string} [styles.color=&#x27;white&#x27;] The text color, the default is white
	 * @param {string} [styles.edge=&#x27;none&#x27;] The edge style, default is none
	 * @param {string} [styles.font=&#x27;arial&#x27;] The font style, default is arial
	 * @param {string} [styles.background=&#x27;black-semi&#x27;] The background style, black semi-transparent
	 * @param {string} [styles.size=&#x27;md&#x27;] The font style default is medium
	 * @param {string} [styles.align=&#x27;top&#x27;] The align style default is top of the window
	 * @param {string} [value] If setting styles parameter as a string, this is the value of the property.
	 */
	p.setCaptionsStyles = function(styles, value)
	{
		if (typeof styles === &quot;object&quot;)
		{
			Object.merge(
				this._captionsStyles,
				styles ||
				{}
			);
		}
		else if (typeof styles === &quot;string&quot;)
		{
			this._captionsStyles[styles] = value;
		}

		styles = this._captionsStyles;

		// Do some validation on the style settings
		if (DEBUG)
		{
			if (!styles.color || !/^(black|white|red|yellow|pink|blue)(-semi)?$/.test(styles.color))
			{
				throw &quot;Setting captions color style is invalid value : &quot; + styles.color;
			}
			if (!styles.background || !/^none|((black|white|red|yellow|pink|blue)(-semi)?)$/.test(styles.background))
			{
				throw &quot;Setting captions background style is invalid value : &quot; + styles.background;
			}
			if (!styles.size || !/^(xs|sm|md|lg|xl)$/.test(styles.size))
			{
				throw &quot;Setting captions size style is invalid value : &quot; + styles.size;
			}
			if (!styles.edge || !/^(raise|depress|uniform|drop|none)$/.test(styles.edge))
			{
				throw &quot;Setting captions edge style is invalid value : &quot; + styles.edge;
			}
			if (!styles.font || !/^(georgia|palatino|times|arial|arial-black|comic-sans|impact|lucida|tahoma|trebuchet|verdana|courier|console)$/.test(styles.font))
			{
				throw &quot;Setting captions font style is invalid value : &quot; + styles.font;
			}
			if (!styles.align || !/^(top|bottom)$/.test(styles.align))
			{
				throw &quot;Setting captions align style is invalid value : &quot; + styles.align;
			}
		}

		SavedData.write(CAPTIONS_STYLES, styles);
		if (this.client)
		{
			this.client.send(CAPTIONS_STYLES, styles);
		}
	};

	/**
	 * Get the captions styles
	 * @method getCaptionsStyles
	 * @param {string} [prop] The optional property, values are &quot;size&quot;, &quot;edge&quot;, &quot;font&quot;, &quot;background&quot;, &quot;color&quot;
	 * @return {object} The collection of styles, see setCaptionsStyles for more info.
	 */
	p.getCaptionsStyles = function(prop)
	{
		var styles = this._captionsStyles;
		return prop ? styles[prop] : styles;
	};

	/**
	 * Reset the captions styles
	 * @method clearCaptionsStyles
	 */
	p.clearCaptionsStyles = function()
	{
		this._captionsStyles = Object.merge(
		{}, DEFAULT_CAPTIONS_STYLES);
		this.setCaptionsStyles();
	};

	/**
	 * Set the captions are enabled or not
	 * @property {boolean} captionsMuted
	 * @default true
	 */
	Object.defineProperty(p, CAPTIONS_MUTED,
	{
		set: function(muted)
		{
			this._captionsMuted = muted;
			this._setMuteProp(CAPTIONS_MUTED, this.captionsButton, muted);
		},
		get: function()
		{
			return this._captionsMuted;
		}
	});

	/**
	 * Set the all sound is enabled or not
	 * @property {boolean} soundMuted
	 * @default false
	 */
	Object.defineProperty(p, SOUND_MUTED,
	{
		set: function(muted)
		{
			this._soundMuted = muted;
			this._setMuteProp(SOUND_MUTED, this.soundButton, muted);
		},
		get: function()
		{
			return this._soundMuted;
		}
	});

	/**
	 * Set the voice-over audio is muted
	 * @property {boolean} voMuted
	 * @default true
	 */
	Object.defineProperty(p, VO_MUTED,
	{
		set: function(muted)
		{
			this._voMuted = muted;
			this._setMuteProp(VO_MUTED, this.voButton, muted);
		},
		get: function()
		{
			return this._voMuted;
		}
	});

	/**
	 * Set the music audio is muted
	 * @property {boolean} musicMuted
	 * @default true
	 */
	Object.defineProperty(p, MUSIC_MUTED,
	{
		set: function(muted)
		{
			this._musicMuted = muted;
			this._setMuteProp(MUSIC_MUTED, this.musicButton, muted);
		},
		get: function()
		{
			return this._musicMuted;
		}
	});

	/**
	 * Set the sound effect audio is muted
	 * @property {boolean} sfxMuted
	 * @default true
	 */
	Object.defineProperty(p, SFX_MUTED,
	{
		set: function(muted)
		{
			this._sfxMuted = muted;
			this._setMuteProp(SFX_MUTED, this.sfxButton, muted);
		},
		get: function()
		{
			return this._sfxMuted;
		}
	});

	/**
	 * Reset all the buttons back to their original setting
	 * and clear the iframe.
	 * @method reset
	 */
	p.reset = function()
	{
		var wasLoaded = this.loaded || this.loading;

		// Stop the focus timer if it&#x27;s running
		if (this._focusTimer)
		{
			clearTimeout(this._focusTimer);
		}

		// Remove bellhop instance
		this.destroyClient();

		// Disable the hint button
		this.helpEnabled = false;

		disableButton(this.soundButton);
		disableButton(this.captionsButton);
		disableButton(this.musicButton);
		disableButton(this.voButton);
		disableButton(this.sfxButton);
		disableButton(this.pauseButton);

		// Reset state
		this.loaded = false;
		this.loading = false;
		this.paused = false;

		// Clear the iframe src location
		this.main.attr(&#x27;src&#x27;, &#x27;&#x27;)
			.removeClass(&#x27;loading&#x27;);

		if (wasLoaded)
		{
			this.off(&#x27;localError&#x27;, this._onCloseFailed);
			this.trigger(&#x27;closed&#x27;);
		}
	};

	/**
	 * Tell the application to start closing
	 * @method close
	 */
	p.close = function()
	{
		if (this.loading || this.loaded)
		{
			this.trigger(&#x27;close&#x27;);

			// If any errors are handled on close, 
			// then we&#x27;ll force close the container
			this.once(&#x27;localError&#x27;, this._onCloseFailed);

			// Start the close
			this.client.send(&#x27;close&#x27;);
		}
		else
		{
			this.reset();
		}
	};

	/**
	 * If there was an error when closing, reset the container
	 * @method _onCloseFailed
	 * @private
	 */
	p._onCloseFailed = function()
	{
		this.reset(); // force close the app
	};

	/**
	 * Disable a button
	 * @method disableButton
	 * @private
	 * @param {jquery} button The button to disable
	 */
	var disableButton = function(button)
	{
		button.removeClass(&#x27;enabled&#x27;)
			.addClass(&#x27;disabled&#x27;);
	};

	/**
	 * Destroy and don&#x27;t use after this
	 * @method destroy
	 */
	p.destroy = function()
	{
		this.reset();

		s.destroy.call(this);

		// Remove listener
		$(document).off(&#x27;focus click&#x27;, this._onDocClick);

		this.main = null;
		this.options = null;
		this.dom = null;

		this._onDocClick = null;
		this.userDataHandler = null;
		this.helpButton = null;
		this.soundButton = null;
		this.pauseButton = null;
		this.captionsButton = null;
		this.musicButton = null;
		this.voButton = null;
		this.sfxButton = null;

		if (this._pageVisibility)
		{
			this._pageVisibility.destroy();
			this._pageVisibility = null;
		}
	};

	namespace(&#x27;springroll&#x27;).Container = Container;
}(document));</pre>
</div></div>
</div>
</div>
</div>
<script src='../assets/js/libraries.js?v=0.4.0'></script>
<script src='../assets/js/main.js?v=0.4.0'></script>
</body>
</html>